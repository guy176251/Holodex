<template>
  <v-container fill-height>
    <v-card
      v-if="menuBool"
      class="TopMenu"
    >
      <v-container class="d-flex align-baseline">
        <v-btn
          elevation="4"
          color="secondary"
          @click="modalMode = 3; modalNexus = true; activeURLInput = activeURLStream;"
        >
          Load Video
        </v-btn>
        <v-btn
          elevation="4"
          color="secondary"
          style="margin-left:5px"
          @click="unloadVideo()"
        >
          Unload Video
        </v-btn>
      </v-container>
    </v-card>
    <div class="d-flex flex-column" style="height:100%; width:100%">
      <v-btn
        block
        elevation="4"
        color="primary"
        small
        @click="menuBool = !menuBool"
      >
        Menu
      </v-btn>
      <div class="d-flex align-stretch flex-row" style="height:100%" @click="menuBool = false">
        <v-card
          ref="tableContainer"
          class="grow"
          height="100%"
          width="50%"
        >
          <v-simple-table
            :fixed-header="!menuBool"
            :height="tableHeightCalculator"
            width="auto"
          >
            <thead @click="selectedEntry = -1;">
              <tr>
                <th class="text-left">
                  Start
                </th>
                <th class="text-left">
                  End
                </th>
                <th class="text-left">
                  Profile
                </th>
                <th class="text-left" style="width: 100%">
                  Text
                </th>
                <th>
                  <v-card-actions v-if="!vidPlayer" class="ControlBox d-flex flex-row">
                    <v-btn small @click="timerTimeStop();">
                      <v-icon dark>
                        {{ mdiStop }}
                      </v-icon>
                    </v-btn>
                    <span>{{ timerPrint }}</span>
                    <v-btn small @click="timerTimeStart();">
                      <v-icon dark>
                        {{ mdiPlay }}
                      </v-icon>
                    </v-btn>
                  </v-card-actions>
                </th>
              </tr>
            </thead>
            <tbody>
              <template v-for="(entry, index) in entries">
                <Entrytr
                  v-if="selectedEntry !== index"
                  :key="index"
                  :time="entry.Time"
                  :end="entry.End"
                  :stext="entry.SText"
                  :profile-name="profile[entry.Profile].Name"
                  :cc="profile[entry.Profile].useCC ? profile[entry.Profile].CC : ''"
                  :oc="profile[entry.Profile].useOC ? profile[entry.Profile].OC : ''"
                  @click.native="selectedEntry = index;"
                />
                <tr v-if="selectedEntry === index" :key="index">
                  <td>{{ timeStampStart }}</td>
                  <td>{{ timeStampEnd }}</td>
                  <td>
                    <v-select
                      v-model="entry.Profile"
                      :items="profileListPicker"
                      item-text="name"
                      item-value="idx"
                      single-line
                    />
                  </td>
                  <td colspan="2">
                    <v-text-field v-model="entry.SText" class="font-weight: bold;" :style="textStyle2" />
                  </td>
                </tr>
                <tr
                  v-if="selectedEntry === index"
                  :key="index + 'control'"
                >
                  <td colspan="5">
                    <v-card-actions
                      class="d-flex flex-row justify-space-around"
                    >
                      <v-btn @click="modalMode = 4; modalNexus = true">
                        Set as start
                      </v-btn>
                      <v-btn @click="shiftToCurrentTime();">
                        Shift to current time
                      </v-btn>
                      <v-btn @click="deleteEntry();">
                        Delete entry
                      </v-btn>
                    </v-card-actions>
                  </td>
                </tr>
              </template>
            </tbody>
          </v-simple-table>
          <v-card v-if="profileDisplay" class="ProfileListCard d-flex flex-column">
            <span v-for="(prf, index) in profile" :key="index"><span v-if="index === profileIdx">> </span>{{ (index + 1) + '. ' + prf.Name }}</span>
          </v-card>
        </v-card>
        <v-card
          v-if="vidPlayer"
          height="100%"
          width="50%"
          class="d-flex flex-column"
          outlined
        >
          <v-card
            id="player"
            height="100%"
            width="100%"
          />
          <v-card
            class="d-flex flex-row justify-center"
          >
            <EnhancedEntry
              v-if="displayEntry >= 0"
              :stext="entries[displayEntry].SText"
              :cc="profile[entries[displayEntry].Profile].useCC ? profile[entries[displayEntry].Profile].CC : ''"
              :oc="profile[entries[displayEntry].Profile].useOC ? profile[entries[displayEntry].Profile].OC : ''"
            />
          </v-card>
          <v-card-actions
            class="d-flex flex-row justify-center"
          >
            <v-btn small @click="timerTimeStop();">
              <v-icon dark>
                {{ mdiStop }}
              </v-icon>
            </v-btn>
            <span>{{ timerPrint }}</span>
            <v-btn small @click="timerTimeStart();">
              <v-icon dark>
                {{ mdiPlay }}
              </v-icon>
            </v-btn>
          </v-card-actions>
        </v-card>
      </div>

      <v-container
        @click="menuBool = false"
        @keydown.up.exact="profileUp()"
        @keydown.down.exact="profileDown()"
        @keydown.tab.exact.prevent="profileDown()"
        @keydown.shift.tab.exact.prevent="profileJumpToDefault()"
        @keydown.ctrl.49.exact.prevent="profileJump(0)"
        @keydown.ctrl.50.exact.prevent="profileJump(1)"
        @keydown.ctrl.51.exact.prevent="profileJump(2)"
        @keydown.ctrl.52.exact.prevent="profileJump(3)"
        @keydown.ctrl.53.exact.prevent="profileJump(4)"
        @keydown.ctrl.54.exact.prevent="profileJump(5)"
        @keydown.ctrl.55.exact.prevent="profileJump(6)"
        @keydown.ctrl.56.exact.prevent="profileJump(7)"
        @keydown.ctrl.57.exact.prevent="profileJump(8)"
        @keydown.ctrl.space="ctrlSpace()"
        @keydown.ctrl.left="ctrlLeft()"
        @keydown.ctrl.right="ctrlRight()"
      >
        <v-row class="align-baseline">
          <v-divider />
          <v-card style="display: flex; flex-direction: column; padding-bottom: 7px; margin-bottom: 5px;">
            <div style="position: relative;">
              <div class="Marker" />

              <div ref="TimelineDiv" class="TimelineContainer" :style="{ scrollBehavior: jumpScrollRender }">
                <div class="TimelineInnerContainer" :style="{ width: 3*secToPx*secPerBar + 'px' }">
                  <canvas ref="TimeCanvas1" :style="{ height: barHeight + 'px', width: secToPx*secPerBar + 'px'}" />
                  <canvas ref="TimeCanvas2" :style="{ height: barHeight + 'px', width: secToPx*secPerBar + 'px'}" />
                  <canvas ref="TimeCanvas3" style="margin-right: auto;" :style="{ height: barHeight + 'px', width: secToPx*secPerBar + 'px'}" />
                </div>

                <div class="TimecardContainer" :style="{ 'margin-left': 'calc(40% + 3px + ' + extraMargin + 'px)', width: 3*secToPx*secPerBar + 'px'}">
                  <div
                    v-for="(idx) in timecardIdx"
                    :key="idx"
                    class="Timecard"
                    :style="{ fontsize: fontSize + 'px', width: cardWidthCalculator(idx)}"
                  >
                    <EnhancedEntry
                      :stext="entries[idx].SText"
                      :cc="profile[entries[idx].Profile].useCC ? profile[entries[idx].Profile].CC : ''"
                      :oc="profile[entries[idx].Profile].useOC ? profile[entries[idx].Profile].OC : ''"
                    />
                  </div>
                </div>
              </div>
            </div>
          </v-card>
          <v-divider />
        </v-row>
        <v-row class="align-baseline">
          <v-text-field
            v-model="inputString"
            @keypress.enter="addEntry()"
          />
          <v-btn style="margin-left:10px" @click="addEntry()">
            Enter
          </v-btn>
        </v-row>
        <v-row class="align-stretch">
          <v-col cols="2">
            <v-text-field
              v-model="profile[profileIdx].Prefix"
              label="Prefix"
              dense
              rounded
              outlined
            />
          </v-col>
          <v-col cols="2">
            <v-text-field
              v-model="profile[profileIdx].Suffix"
              label="Suffix"
              dense
              rounded
              outlined
            />
          </v-col>
          <v-checkbox
            v-model="profile[profileIdx].useCC"
            class="shrink"
            label="Font Colour : "
            hide-details
          />
          <v-btn
            class="ColourButton"
            small
            :style="{ background: profile[profileIdx].CC }"
            @click.stop="colourTemp = profile[profileIdx].CC; colourPick = 1; colourDialogue = true;"
          >
            {{ profile[profileIdx].CC }}
          </v-btn>
          <v-checkbox
            v-model="profile[profileIdx].useOC"
            label="Outline Colour : "
            hide-details
          />
          <v-btn
            class="ColourButton"
            small
            :style="{ background: profile[profileIdx].OC }"
            @click.stop="colourTemp = profile[profileIdx].OC; colourPick = 2; colourDialogue = true;"
          >
            {{ profile[profileIdx].OC }}
          </v-btn>
        </v-row>
        <v-row>
          <v-btn @click="modalMode = 1; modalNexus = true; addProfileNameString = 'Profile ' + profile.length;">
            Add Profile
          </v-btn>
          <v-btn @click="modalMode = 2; modalNexus = true">
            Remove Profile
          </v-btn>
          <v-btn @click="shiftProfileUp()">
            Shift Up
          </v-btn>
          <v-btn @click="shiftProfileDown()">
            Shift Down
          </v-btn>
        </v-row>
      </v-container>
    </div>

    <!---------   COLOUR MODAL --------->
    <v-dialog
      v-model="colourDialogue"
      max-width="300px"
      @click:outside.prevent="colourPickerClose();"
    >
      <v-card>
        <v-color-picker v-if="colourPick === 1" v-model="profile[profileIdx].CC" />
        <v-color-picker v-else-if="colourPick === 2" v-model="profile[profileIdx].OC" />
        <v-card-title :style="textStyle" style="font-weight:bold;">
          The quick brown fox jumps over the lazy dog
        </v-card-title>
        <v-card-actions>
          <v-btn @click="colourPickerClose();">
            Cancel
          </v-btn>

          <v-btn style="margin-left:auto" @click="colourPickerOK()">
            Ok
          </v-btn>
        </v-card-actions>
      </v-card>
    </v-dialog>
    <!--========   COLOUR MODAL =======-->

    <!---------   NEXUS MODAL ---------
      1 Add profile
      2 Remove Profile
      3 Load Stream
      4 Set as Start
      6 Login Check
    -->
    <v-dialog
      v-model="modalNexus"
      max-width="600px"
      persistent
      @click:outside="modalNexusOutsideClick();"
    >
      <!---------    ADD PROFILE     --------->
      <v-card v-if="modalMode === 1">
        <v-container>
          <v-card-title>
            Add New Profile.
          </v-card-title>
          <v-text-field
            v-model="addProfileNameString"
            label="Profile Name"
            placeholder="Profile Name"
            dense
            rounded
            outlined
          />
          <v-card-actions>
            <v-btn @click="modalNexus = false">
              Cancel
            </v-btn>

            <v-btn style="margin-left:auto" @click="addProfile()">
              Ok
            </v-btn>
          </v-card-actions>
        </v-container>
      </v-card>

      <!---------    Remove PROFILE     --------->
      <v-card v-if="modalMode === 2">
        <v-container>
          <v-card-title>
            Confirm remove profile {{ profile[profileIdx].Name }}.
          </v-card-title>
          <v-card-actions>
            <v-btn @click="modalNexus = false">
              Cancel
            </v-btn>

            <v-btn style="margin-left:auto" @click="deleteProfile()">
              Ok
            </v-btn>
          </v-card-actions>
        </v-container>
      </v-card>

      <!-------  LOAD VIDEO  ------->
      <v-card v-if="modalMode === 3">
        <v-container>
          <v-card-title>
            Load Video
          </v-card-title>
          <v-text-field v-model="activeURLInput" label="Stream Link" />
          <v-card-actions>
            <v-btn @click="modalNexus = false">
              Cancel
            </v-btn>

            <v-btn style="margin-left:auto" @click="loadVideo(); modalNexus = false;">
              Ok
            </v-btn>
          </v-card-actions>
        </v-container>
      </v-card>

      <!-------  SET START ENTRY  ------->
      <v-card v-if="modalMode === 4">
        <v-container>
          <v-card-title>
            Set selected entry as start, all the previous entries will be deleted.
          </v-card-title>
          <v-card-actions>
            <v-btn @click="modalNexus = false">
              Cancel
            </v-btn>

            <v-btn style="margin-left:auto" @click="setStartEntry(); modalNexus = false;">
              Ok
            </v-btn>
          </v-card-actions>
        </v-container>
      </v-card>

      <!-------  LOGGIN IN CHECK ------->
      <v-card v-if="modalMode === 6">
        <v-container>
          <v-card-title>
            {{ loginStatusText }}
          </v-card-title>

          <v-card v-if="(loginStatus === 2) || (loginStatus === 3) || (loginStatus === 4)">
            <v-divider />
            <v-card-subtitle>
              {{ (loginNoteText === '') ? '' : 'Message from reviewer : ' + loginNoteText }}
            </v-card-subtitle>
            <v-text-field v-if="loginStatus !== 4" v-model="applicationText" label="Note" />
            <v-divider />
          </v-card>

          <v-card-actions>
            <v-btn href="/">
              Back
            </v-btn>
            <v-btn v-if="loginStatus===-1" style="margin-left:auto" href="/login">
              Login
            </v-btn>

            <v-btn v-if="loginStatus===2" style="margin-left:auto" @click="applyTL();">
              Apply
            </v-btn>

            <v-btn v-if="loginStatus===3" style="margin-left:auto" @click="applyTL();">
              Re-apply
            </v-btn>
          </v-card-actions>
        </v-container>
      </v-card>
    </v-dialog>
    <!--========   NEXUS MODAL =======-->
  </v-container>
</template>

<script lang="ts">
import Entrytr from "@/components/tlscripteditor/Entrytr.vue";
import EnhancedEntry from "@/components/tlscripteditor/EnhancedEntry.vue";
import { TL_LANGS } from "@/utils/consts";
import { mdiPlay, mdiStop } from "@mdi/js";
import { getVideoIDFromUrl } from "@/utils/functions";
import backendApi from "@/utils/backend-api";

import Vue from "vue";
import LoadScript from "vue-plugin-load-script";

Vue.use(LoadScript);

export default {
    name: "Tlscripteditor",
    metaInfo() {
        return {
            get title() {
                return "TLScriptEditor - Holodex";
            },
        };
    },
    components: {
        EnhancedEntry,
        Entrytr,
    },
    data() {
        return {
            TL_LANGS,
            mdiPlay,
            mdiStop,
            menuBool: false,
            entries: [],
            profile: [{
                Name: "Default",
                Prefix: "",
                Suffix: "",
                useCC: false,
                CC: "#000000",
                useOC: false,
                OC: "#000000",
            }],
            profileContainer: {},
            profileIdx: 0,
            profileDisplay: false,
            profileDisplayTimer: undefined,
            inputString: "",
            tableHeight: 0,
            selectedEntry: -1,
            fontSize: 15,
            // ------ COLOUR -------
            colourPick: 0,
            colourDialogue: false,
            colourTemp: "",
            // ------ MODAL --------
            modalNexus: true,
            modalMode: 6,
            addProfileNameString: "",
            // ------ SETTING ------
            TLLang: TL_LANGS[0],
            mainStreamLink: "",
            collabLinks: [""],
            // ---- ACTIVE VIDEO ----
            activeURLInput: "",
            activeURLStream: "",
            vidType: "",
            vidPlayer: false,
            vidIframeEle: null,
            player: null,
            IFOrigin: "",
            // ---- PRIVILIGE CHECK ----
            loginStatusText: "Checking login status...",
            loginStatus: 0, // 0: check login status, 1: check TL privilege, 2: not applied, 3: application rejected, 4: banned
            loginNoteText: "",
            applicationText: "",
            loggedInTL: true,
            // ---- TIMER CONTROLLER ----
            timerTime: 0,
            timerDelegate: undefined,
            timeSaddle: Date.now(),
            refreshRate: 33,
            trackerPause: true,
            // ---- TIMELINE ----
            timelineDur: 3600,
            secToPx: 100,
            secPerBar: 120,
            barHeight: 25,
            extraMargin: 0,
            jumpScroll: true,
            barCount: 0,
            displayEntry: 0,
            timecardIdx: [],

        };
    },
    computed: {
        tableHeightCalculator() {
            return (`${this.tableHeight}px`);
        },
        textStyle() {
            return {
                "-webkit-text-fill-color": (this.profile[this.profileIdx].CC === "") ? "unset" : this.profile[this.profileIdx].CC,
                "-webkit-text-stroke-color": (this.profile[this.profileIdx].OC === "") ? "unset" : this.profile[this.profileIdx].OC,
                "-webkit-text-stroke-width": (this.profile[this.profileIdx].OC === "") ? "0px" : "1px",
            };
        },
        userdata() {
            return this.$store.state.userdata;
        },
        user() {
            return this.$store.state.userdata.user;
        },
        timerPrint() {
            let timeRaw = this.timerTime;
            let timeString = "";

            let t = Math.floor(timeRaw / 60 / 60 / 1000);
            timeRaw -= t * 60 * 60 * 1000;
            if (t < 10) {
                timeString += `0${t.toString()}`;
            } else {
                timeString += t.toString();
            }
            timeString += ":";

            t = Math.floor(timeRaw / 60 / 1000);
            timeRaw -= t * 60 * 1000;
            if (t < 10) {
                timeString += `0${t.toString()}`;
            } else {
                timeString += t.toString();
            }
            timeString += ":";

            t = Math.floor(timeRaw / 1000);
            timeRaw -= t * 1000;
            if (t < 10) {
                timeString += `0${t.toString()}`;
            } else {
                timeString += t.toString();
            }
            timeString += ".";

            if (timeRaw > 100) {
                timeString += timeRaw.toString().slice(0, 2);
            } else if (timeRaw > 10) {
                timeString += `0${timeRaw.toString().slice(0, 1)}`;
            } else {
                timeString += "00";
            }

            return timeString;
        },
        timeStampStart() {
            let timeRaw = this.entries[this.selectedEntry].Time;
            let timeString = "";

            let t = Math.floor(timeRaw / 60 / 60 / 1000);
            timeRaw -= t * 60 * 60 * 1000;
            if (t < 10) {
                timeString += `0${t.toString()}`;
            } else {
                timeString += t.toString();
            }
            timeString += ":";

            t = Math.floor(timeRaw / 60 / 1000);
            timeRaw -= t * 60 * 1000;
            if (t < 10) {
                timeString += `0${t.toString()}`;
            } else {
                timeString += t.toString();
            }
            timeString += ":";

            t = Math.floor(timeRaw / 1000);
            timeRaw -= t * 1000;
            if (t < 10) {
                timeString += `0${t.toString()}`;
            } else {
                timeString += t.toString();
            }
            timeString += ".";

            if (timeRaw > 100) {
                timeString += timeRaw.toString().slice(0, 2);
            } else if (timeRaw > 10) {
                timeString += `0${timeRaw.toString().slice(0, 1)}`;
            } else {
                timeString += "00";
            }

            return timeString;
        },
        timeStampEnd() {
            let timeRaw = this.entries[this.selectedEntry].End;
            let timeString = "";

            let t = Math.floor(timeRaw / 60 / 60 / 1000);
            timeRaw -= t * 60 * 60 * 1000;
            if (t < 10) {
                timeString += `0${t.toString()}`;
            } else {
                timeString += t.toString();
            }
            timeString += ":";

            t = Math.floor(timeRaw / 60 / 1000);
            timeRaw -= t * 60 * 1000;
            if (t < 10) {
                timeString += `0${t.toString()}`;
            } else {
                timeString += t.toString();
            }
            timeString += ":";

            t = Math.floor(timeRaw / 1000);
            timeRaw -= t * 1000;
            if (t < 10) {
                timeString += `0${t.toString()}`;
            } else {
                timeString += t.toString();
            }
            timeString += ".";

            if (timeRaw > 100) {
                timeString += timeRaw.toString().slice(0, 2);
            } else if (timeRaw > 10) {
                timeString += `0${timeRaw.toString().slice(0, 1)}`;
            } else {
                timeString += "00";
            }

            return timeString;
        },
        textStyle2() {
            return {
                "-webkit-text-fill-color": (!this.profile[this.entries[this.selectedEntry].Profile].useCC) ? "unset" : this.profile[this.entries[this.selectedEntry].Profile].CC,
                "-webkit-text-stroke-color": (!this.profile[this.entries[this.selectedEntry].Profile].useOC) ? "unset" : this.profile[this.entries[this.selectedEntry].Profile].OC,
                "-webkit-text-stroke-width": (!this.profile[this.entries[this.selectedEntry].Profile].useOC) ? "0px" : "1px",
            };
        },
        profileListPicker() {
            const profileList = [];
            for (let i = 0; i < this.profile.length; i += 1) {
                profileList.push({
                    idx: i,
                    name: this.profile[i].Name,
                });
            } return profileList;
        },
        jumpScrollRender() {
            return (this.jumpScroll ? "unset" : "smooth");
        },
    },
    watch: {
        timerTime() {
            this.scrollCalculator();
            if (this.entries.length === 0) {
                this.displayEntry = -1;
                return;
            }

            if (this.displayEntry < 0) {
                for (let i = 0; i < this.entries.length; i += 1) {
                    if (this.entries[i].Time > this.timerTime) {
                        this.displayEntry = i - 1;
                        return;
                    } if (i === this.entries.length - 1) {
                        this.displayEntry = i;
                        return;
                    }
                }
            } else if (this.entries[this.displayEntry].Time > this.timerTime) {
                for (let i = this.displayEntry - 1; i > 0; i -= 1) {
                    if (this.entries[i].End > this.timerTime) {
                        this.displayEntry = i;
                        return;
                    } if (i >= this.entries.length) {
                        this.displayEntry = 0;
                        return;
                    }
                }
            } else if (this.entries[this.displayEntry].End < this.timerTime) {
                for (let i = this.displayEntry + 1; i < this.entries.length; i += 1) {
                    if (this.entries[i].Time > this.timerTime) {
                        this.displayEntry = i - 1;
                        return;
                    } if (i === this.entries.length - 1) {
                        this.displayEntry = i;
                        return;
                    }
                }
            }
        },
    },
    mounted() {
        this.checkLoginValidity();
        this.rerenderTimeline();
    },
    created() {
        window.addEventListener("resize", this.onResize);
        const checker = setInterval(() => {
            this.tableHeight = this.$refs.tableContainer.$el.clientHeight - 20;
            if (this.tableHeight !== 0) {
                clearInterval(checker);
            }
        }, 33);
    },
    beforeDestroy() {
        this.unloadVideo();
        window.removeEventListener("resize", this.onResize);
    },
    methods: {
        onResize() {
            this.tableHeight = 0;
            const checker = setInterval(() => {
                this.tableHeight = this.$refs.tableContainer.$el.clientHeight - 20;
                if (this.tableHeight !== 0) {
                    clearInterval(checker);
                }
            }, 33);
        },
        addEntry() {
            const dt = {
                Time: this.timerTime,
                End: this.timerTime + 3000,
                SText: this.profile[this.profileIdx].Prefix + this.inputString + this.profile[this.profileIdx].Suffix,
                Profile: this.profileIdx,
            };

            let inserted:boolean = false;
            for (let i = 0; i < this.entries.length; i += 1) {
                if (this.entries[i].Time > dt.Time) {
                    if (i > 0) {
                        this.entries[i - 1].End = dt.Time;
                    }

                    if (i < this.entries.length) {
                        dt.End = this.entries[i].Time;
                    }

                    this.entries.splice(i, 0, dt);
                    this.displayEntry = i;
                    inserted = true;
                    this.inputString = "";
                    return;
                }
            }

            if (!inserted) {
                if (this.entries.length !== 0) {
                    this.entries[this.entries.length - 1].End = dt.Time;
                }
                this.entries.push(dt);
                this.displayEntry = this.entries.length - 1;
                this.inputString = "";
                this.reloadDisplayCards();
            }
        },
        deleteAuxLink(idx: number) {
            if (this.collabLinks.length !== 1) {
                this.collabLinks.splice(idx, 1);
            }
        },
        modalNexusOutsideClick() {
            if ((this.modalMode !== 3) && this.loggedInTL) {
                this.modalNexus = false;
            }
        },
        // ----------------------- TIMER CONTROLLER -----------------------
        timerTimeStart() {
            if (this.vidPlayer) {
                switch (this.vidType) {
                    case "twitch":
                        this.player.play();
                        break;

                    case "twitch_vod":
                        this.player.play();
                        break;

                    case "twitcast":
                        this.startPing();
                        break;

                    case "twitcast_vod":
                        this.startPing();
                        break;

                    case "niconico":
                        break;

                    case "niconico_vod":
                        this.startPing();
                        break;

                    case "bilibili":
                        break;

                    case "bilibili_vod":
                        this.startPing();
                        break;

                    default:
                        this.player.playVideo();
                        break;
                }
            } else if (!this.timerDelegate) {
                this.timeSaddle = Date.now();
                this.timerDelegate = setInterval(() => {
                    if (Date.now() - this.timeSaddle < 1000) {
                        this.timerTime += Date.now() - this.timeSaddle;
                    }
                    this.timeSaddle = Date.now();
                // this.ScrollCalculator();
                }, this.refreshRate);
            }
        },
        timerTimeStop() {
            if (this.vidPlayer) {
                switch (this.vidType) {
                    case "twitch":
                        this.player.pause();
                        break;

                    case "twitch_vod":
                        this.player.pause();
                        break;

                    case "twitcast":
                        this.pausePing();
                        break;

                    case "twitcast_vod":
                        this.pausePing();
                        break;

                    case "niconico":
                        break;

                    case "niconico_vod":
                        this.pausePing();
                        break;

                    case "bilibili":
                        break;

                    case "bilibili_vod":
                        this.pausePing();
                        break;

                    default:
                        this.player.pauseVideo();
                        break;
                }
            } else if (this.timerDelegate) {
                clearInterval(this.timerDelegate);
                this.timerDelegate = undefined;
            }
        },
        seekVideo(time:number) {
            if (this.vidPlayer) {
                switch (this.vidType) {
                    case "twitch":
                        // NO
                        break;

                    case "twitch_vod":
                        this.player.seek(this.timerTime / 1000 + time / 1000);
                        break;

                    case "twitcast":
                        // NO
                        break;

                    case "twitcast_vod":
                        this.timePing(time);
                        break;

                    case "niconico":
                        break;

                    case "niconico_vod":
                        this.timePing(time);
                        break;

                    case "bilibili":
                        break;

                    case "bilibili_vod":
                        this.timePing(time);
                        break;

                    default:
                        this.player.seekTo(this.player.getCurrentTime() + time / 1000, true);
                        break;
                }
            } else if (this.timerTime + time < 0) {
                this.timerTime = 0;
            } else {
                this.timerTime += time;
            }
        },
        ctrlRight() {
            this.seekVideo(3000);
        },
        ctrlLeft() {
            this.seekVideo(-3000);
        },
        ctrlSpace() {
            if (this.vidPlayer) {
                switch (this.vidType) {
                    case "twitch":
                        if (this.player.isPaused()) {
                            this.timerTimeStart();
                        } else {
                            this.timerTimeStop();
                        }
                        break;

                    case "twitch_vod":
                        if (this.player.isPaused()) {
                            this.timerTimeStart();
                        } else {
                            this.timerTimeStop();
                        }
                        break;

                    case "twitcast":
                        this.switchPing();
                        break;

                    case "twitcast_vod":
                        this.switchPing();
                        break;

                    case "niconico":
                        break;

                    case "niconico_vod":
                        this.switchPing();
                        break;

                    case "bilibili":
                        break;

                    case "bilibili_vod":
                        this.switchPing();
                        break;

                    default:
                        if (this.player.getPlayerState() !== 1) {
                            this.timerTimeStart();
                        } else if (this.player.getPlayerState() === 1) {
                            this.timerTimeStop();
                        }
                        break;
                }
            } else if (this.timerDelegate) {
                this.timerTimeStop();
            } else {
                this.timerTimeStart();
            }
        },
        //= ====================== TIMER CONTROLLER =======================

        // ------------------------ PROFILE CONTROLLER ------------------------
        shiftProfileUp() {
            if (this.profileIdx > 1) {
                this.profileContainer = JSON.parse(JSON.stringify(this.profile[this.profileIdx - 1]));
                this.profile[this.profileIdx - 1] = this.profile[this.profileIdx];
                this.profile[this.profileIdx] = this.profileContainer;
                this.profileIdx -= 1;
                this.profileContainer = {};
            }
            this.showProfileList();
        },
        shiftProfileDown() {
            if ((this.profileIdx !== 0) && (this.profileIdx < this.profile.length - 1)) {
                this.profileContainer = JSON.parse(JSON.stringify(this.profile[this.profileIdx + 1]));
                this.profile[this.profileIdx + 1] = this.profile[this.profileIdx];
                this.profile[this.profileIdx] = this.profileContainer;
                this.profileIdx += 1;
                this.profileContainer = {};
            }
            this.showProfileList();
        },
        profileUp() {
            if (this.profileIdx === 0) {
                this.profileIdx = this.profile.length - 1;
            } else {
                this.profileIdx -= 1;
            }
            this.showProfileList();
        },
        profileDown() {
            if (this.profileIdx === this.profile.length - 1) {
                this.profileIdx = 0;
            } else {
                this.profileIdx += 1;
            }
            this.showProfileList();
        },
        profileJump(idx: number) {
            if (idx < this.profile.length) {
                this.profileIdx = idx;
            }
            this.showProfileList();
        },
        profileJumpToDefault() {
            this.profileIdx = 0;
            this.showProfileList();
        },
        addProfile() {
            if (this.addProfileNameString.trim() === "") {
                this.addProfileNameString = `Profile ${this.profile.length}`;
            }
            this.profile.push({
                Name: this.addProfileNameString,
                Prefix: "",
                Suffix: "",
                useCC: false,
                CC: "#000000",
                useOC: false,
                OC: "#000000",
            });
            this.profileIdx = this.profile.length - 1;
            this.modalNexus = false;
            this.showProfileList();
        },
        deleteProfile() {
            if (this.profileIdx !== 0) {
                this.entries.filter((e) => e.Profile === this.profileIdx).map((e) => {
                    e.Profile = 0;
                    return (e);
                });

                this.profileIdx -= 1;
                this.profile.splice(this.profileIdx + 1, 1);
            }
            this.modalNexus = false;
            this.showProfileList();
        },
        showProfileList() {
            if (!this.profileDisplay) {
                this.profileDisplay = true;
            }

            if (this.profileDisplayTimer) {
                clearInterval(this.profileDisplayTimer);
            }

            this.profileDisplayTimer = setInterval(() => {
                this.profileDisplay = false;
                clearInterval(this.profileDisplayTimer);
            }, 3000);
        },
        colourPickerClose() {
            if (this.colourPick === 1) {
                this.profile[this.profileIdx].CC = this.colourTemp;
            } else if (this.colourPick === 2) {
                this.profile[this.profileIdx].OC = this.colourTemp;
            }
            this.colourDialogue = false;
        },
        colourPickerOK() {
            this.colourDialogue = false;
        },
        //= ======================== PROFILE CONTROLLER ========================

        // ---------------------- VIDEO CONTROLLER ----------------------
        loadVideo() {
            this.activeURLStream = this.activeURLInput;
            this.vidPlayer = true;
            const checker = setInterval(() => {
                const PlayerDiv = document.getElementById("player");
                if (PlayerDiv) {
                    clearInterval(checker);
                    if (this.timerDelegate) {
                        clearInterval(this.timerDelegate);
                        this.timerDelegate = undefined;
                    }
                    const StreamURL = getVideoIDFromUrl(this.activeURLStream);
                    if (StreamURL) {
                        this.vidType = StreamURL.type;
                        switch (StreamURL.type) {
                            case "twitch":
                                this.loadVideoTW(StreamURL.id, true);
                                break;

                            case "twitch_vod":
                                this.loadVideoTW(StreamURL.id, false);
                                break;

                            case "twitcast":
                                this.setupIframeTC(StreamURL.id, StreamURL.id, true);
                                break;

                            case "twitcast_vod":
                                this.setupIframeTC(StreamURL.id, StreamURL.channel.name, false);
                                break;

                            case "niconico":
                                // niconico doesn't allow third party player hosting... at least for now...
                                // this.setupIframeNC(StreamURL.id, true);
                                break;

                            case "niconico_vod":
                                this.setupIframeNC(StreamURL.id, false);
                                break;

                            case "bilibili":
                                // bilibili live player is flash -> the one in FLASH link in the share button
                                // https://s1.hdslb.com/bfs/static/blive/live-assets/player/flash/pageplayer-latest.swf?room_id=0&cid=xxxxxx&state=LIVE
                                break;

                            case "bilibili_vod":
                                this.setupIframeBL(StreamURL.id);
                                break;

                            default:
                                this.loadVideoYT(StreamURL.id);
                                break;
                        }
                    }
                }
            }, 1000);
        },
        unloadVideo() {
            this.vidPlayer = false;
            if (this.timerDelegate) {
                clearInterval(this.timerDelegate);
                this.timerDelegate = undefined;
            }

            if (this.vidIframeEle) {
                window.removeEventListener("message", (e:any) => {
                    this.iframeVideoListener(e);
                });
            }

            if (((this.vidType === "twitch") || (this.vidType === "twitch_vod")) && (window.Twitch)) {
                this.player.removeEventListener(window.Twitch.Player.PAUSE, () => {
                    this.pauseTracker = true;
                });

                this.player.removeEventListener(window.Twitch.Player.PLAY, () => {
                    this.pauseTracker = false;
                });

                this.player.removeEventListener(window.Twitch.Player.SEEK, (e: any) => {
                    this.timerTime = e.position * 1000;
                    // this.ScrollCalculator();
                });
            }
        },
        setupIframeTC(MID: string, UID: string, Live: boolean): void {
            if (this.vidIframeEle) {
                this.vidIframeEle.parentNode?.removeChild(this.vidIframeEle);
            }
            this.vidIframeEle = document.createElement("iframe");
            if (Live) {
                this.vidIframeEle.src = `https://twitcasting.tv/${UID}/embeddedplayer/live?auto_play=false&default_mute=false`;
                this.vidIframeEle.loading = "lazy";
            } else {
                this.vidIframeEle.src = `https://twitcasting.tv/${UID}/embeddedplayer/${MID}?auto_play=false&default_mute=false`;
            }
            this.vidIframeEle.width = "100%";
            this.vidIframeEle.height = "100%";
            this.vidIframeEle.frameBorder = "0";

            this.loadIframe("TC");
        },
        setupIframeBL(VID: string): void {
            let embedID = "";
            if (this.vidIframeEle) {
                this.vidIframeEle.parentNode?.removeChild(this.vidIframeEle);
            }

            switch (VID.slice(0, 2).toLowerCase()) {
                case "bv":
                    embedID = `bvid=${VID.slice(2)}`;
                    break;

                case "av":
                    embedID = `aid=${VID.slice(2)}`;
                    break;

                default:
                    embedID = `cid=${VID}`;
                    break;
            }

            this.vidIframeEle = document.createElement("iframe");
            this.vidIframeEle.src = `https://player.bilibili.com/player.html?${embedID}&page=1&as_wide=1&high_quality=0&danmaku=0`;
            this.vidIframeEle.width = "100%";
            this.vidIframeEle.height = "100%";
            this.vidIframeEle.frameBorder = "0";

            this.loadIframe("BL");
        },
        setupIframeNC(VID: string, Live: boolean): void {
            if (this.vidIframeEle) {
                this.vidIframeEle.parentNode?.removeChild(this.vidIframeEle);
            }

            this.vidIframeEle = document.createElement("iframe");
            if (Live) {
                this.vidIframeEle.src = `https://live.nicovideo.jp/embed/${VID}`;
            } else {
                this.vidIframeEle.src = `https://embed.nicovideo.jp/watch/${VID}?autoplay=0`;
            }
            this.vidIframeEle.width = "100%";
            this.vidIframeEle.height = "100%";
            this.vidIframeEle.frameBorder = "0";
            this.vidIframeEle.allow = "encrypted-media;";

            this.loadIframe("NC");
        },

        // -----------------  IFRAME  -----------------
        timePing(timestamp: number): void {
            if (this.vidIframeEle?.contentWindow) {
                this.vidIframeEle?.contentWindow.postMessage({
                    n: "HolodexSync",
                    d: timestamp,
                }, this.IFOrigin);
            }
        },
        modePing(Mode: string): void {
            switch (Mode) {
                case "TC":
                    this.IFOrigin = "https://twitcasting.tv";
                    break;

                case "NC":
                    this.IFOrigin = "https://embed.nicovideo.jp";
                    break;

                case "BL":
                    this.IFOrigin = "https://player.bilibili.com";
                    break;

                default:
                    this.IFOrigin = "";
                    break;
            }

            if (this.vidIframeEle?.contentWindow) {
                this.vidIframeEle?.contentWindow.postMessage({
                    n: "HolodexSync",
                    d: Mode,
                }, this.IFOrigin);
            }
        },
        startPing(): void {
            if (this.vidIframeEle?.contentWindow) {
                this.vidIframeEle?.contentWindow.postMessage({
                    n: "HolodexSync",
                    d: "s",
                }, this.IFOrigin);
            }
        },
        pausePing(): void {
            if (this.vidIframeEle?.contentWindow) {
                this.vidIframeEle?.contentWindow.postMessage({
                    n: "HolodexSync",
                    d: "p",
                }, this.IFOrigin);
            }
        },
        switchPing(): void {
            if (this.vidIframeEle?.contentWindow) {
                this.vidIframeEle?.contentWindow.postMessage({
                    n: "HolodexSync",
                    d: "w",
                }, this.IFOrigin);
            }
        },
        loadIframe(Mode: string): void {
            if (this.vidIframeEle) {
                const PlayerDiv = document.getElementById("player");
                if (PlayerDiv) {
                    PlayerDiv.append(this.vidIframeEle);

                    this.vidIframeEle.onload = () => {
                        this.modePing(Mode);
                    };

                    window.addEventListener("message", (e:any) => {
                        this.iframeVideoListener(e);
                    });
                }
            }
        },
        iframeVideoListener(e: any):void {
            if (e.origin === this.IFOrigin) {
                if (e.data.n === "SyncHolodex") {
                    if (typeof e.data.d === "number") {
                        this.timerTime = e.data.d;
                        // this.ScrollCalculator();
                    }
                }
            }
        },
        //= ================  IFRAME  =================

        // -----------------  YT  -----------------
        loadVideoYT(VID: string) {
            if (window.YT) {
                this.startVideoYT(VID);
                return;
            }

            const tag = document.createElement("script");
            tag.src = "https://www.youtube.com/iframe_api";
            const firstScriptTag = document.getElementsByTagName("script")[0];
            if (firstScriptTag.parentNode) {
                firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
            }

            window.onYouTubeIframeAPIReady = () => this.startVideoYT(VID);
        },
        startVideoYT(VID: string) {
            this.player = new window.YT.Player("player", {
                videoId: VID,
                playerVars: {
                    playsinline: 1,
                },
                events: {
                    onReady: this.readyStateYT.bind(this),
                },
            });
        },
        readyStateYT() {
            this.startTrackerYT();
        },
        startTrackerYT(): void {
            if (this.timerDelegate) {
                clearInterval(this.timerDelegate);
                this.timerDelegate = undefined;
            }
            this.timerDelegate = setInterval(() => {
                this.timerTime = this.player.getCurrentTime() * 1000;
            // this.ScrollCalculator();
            }, 100);
        },
        //= ================  YT  =================

        // -----------------  TW  -----------------
        loadVideoTW(VID:string, Live: boolean) {
            this.startTWTracker();
            if (window.Twitch) {
                this.startVideoTW(VID, Live);
                return;
            }

            const tag = document.createElement("script");
            tag.src = "https://player.twitch.tv/js/embed/v1.js";
            const firstScriptTag = document.getElementsByTagName("script")[0];
            if (firstScriptTag.parentNode) {
                firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
            }

            const Checker = setInterval(() => {
                if (window.Twitch) {
                    clearInterval(Checker);
                    this.startVideoTW(VID, Live);
                }
            }, 1000);
        },
        startVideoTW(VID: string, Live: boolean) {
            if (Live) {
                this.player = new window.Twitch.Player("player", {
                    width: "100%",
                    height: "100%",
                    channel: VID,
                    autoplay: false,
                    time: "0h0m0s",
                });
            } else {
                this.player = new window.Twitch.Player("player", {
                    width: "100%",
                    height: "100%",
                    video: VID,
                    autoplay: false,
                    time: "0h0m0s",
                });
            }

            this.player.addEventListener(window.Twitch.Player.PAUSE, () => {
                this.trackerPause = true;
            });

            this.player.addEventListener(window.Twitch.Player.PLAY, () => {
                this.trackerPause = false;
            });

            this.player.addEventListener(window.Twitch.Player.SEEK, (e: any) => {
                this.timerTime = e.position * 1000;
                // this.ScrollCalculator();
            });
        },
        startTWTracker() {
            this.trackerPause = true;
            if (this.timerDelegate) {
                clearInterval(this.timerDelegate);
            }

            this.timeSaddle = Date.now();
            this.timerDelegate = setInterval(() => {
                if ((Date.now() - this.timeSaddle < 1000) && (!this.trackerPause)) {
                    this.timerTime += Date.now() - this.timeSaddle;
                }
                this.timeSaddle = Date.now();
                // this.ScrollCalculator();
            }, this.refreshRate);
        },
        //= ================  TW  =================

        //= ====================== VIDEO CONTROLLER ======================

        // ------------------------ LOGIN STATUS CHECK ------------------------
        async checkLoginValidity() {
            const check = await backendApi.loginIsValid(this.userdata.jwt);
            if (check === false) {
                this.$store.dispatch("logout");
                this.loginStatus = -1;
                this.loginStatusText = "User not logged in.";
            } else if (check.data && check.data.id) {
                this.$store.commit("setUser", { user: check.data, jwt: this.userdata.jwt });
                this.loginStatus = 1;
                this.loginStatusText = "Logged in, checking TL privilege...";
                this.checkUserTLStatus();
            }
        },
        async checkUserTLStatus() {
            backendApi.checkTLStatus({
                id: this.user.id,
            }).then(({ status, data }) => {
                if (status === 200) {
                    switch (data.status) {
                        case "OK":
                            this.loginStatusText = "OK!";
                            this.modalMode = 3;
                            return;

                        case "BANNED":
                            this.loginStatusText = "Banned.";
                            this.loginNoteText = data.note;
                            this.loginStatus = 4;
                            return;

                        case "REJECTED":
                            this.loginStatusText = "Application rejected.";
                            this.loginNoteText = data.note;
                            this.applicationText = "Add note here to help review your application, it can be your qualification or link to past stream that you've translated.";
                            this.loginStatus = 3;
                            return;

                        case "APPLIED":
                            this.loginStatusText = "Application has been sent, still waiting for review.";
                            this.loginStatus = -2;
                            return;

                        case "NOT":
                            this.loginStatusText = "Not applied for TL role.";
                            this.applicationText = "Add note here to help review your application, it can be your qualification or link to past stream that you've translated.";
                            this.loginStatus = 2;
                            return;

                        default:
                            this.loginStatus = -2;
                            this.loginStatusText = "Can't reach server";
                    }
                } else {
                    this.loginStatus = -2;
                    this.loginStatusText = "Can't reach server";
                }
            }).catch((err) => {
                this.loginStatus = -2;
                this.loginStatusText = "Can't reach server";
                console.log(err);
            });
        },
        applyTL() {
            backendApi.applyTL({
                id: this.user.id,
                applynote: this.applicationText,
            }).then(({ status }) => {
                if (status === 200) {
                    this.loginStatusText = "Application sent! Please be patient while we check your application...";
                    this.loginStatus = -2;
                } else {
                    this.loginStatus = -2;
                    this.loginStatusText = "Can't reach server";
                }
            }).catch((err) => {
                this.loginStatus = -2;
                this.loginStatusText = "Can't reach server";
                console.log(err);
            });
        },
        //= ======================= LOGIN STATUS CHECK ========================

        //= =----------------------- ENTRY CONTROLLER ------------------------
        deleteEntry() {
            const tempEntries = JSON.parse(JSON.stringify(this.entries[this.selectedEntry]));
            this.displayEntry = -1;
            this.entries.splice(this.selectedEntry, 1);
            if (this.selectedEntry === 0) {
                if (this.entries.length > 0) {
                    this.entries[0].Time = tempEntries.Time;
                }
            } else if (this.selectedEntry < this.entries.length) {
                this.entries[this.selectedEntry - 1].End = tempEntries.End;
            }

            this.selectedEntry = -1;
        },
        setStartEntry() {
            this.entries.splice(0, this.selectedEntry);
            this.selectedEntry = -1;
            const timeCut = this.entries[0].Time;
            this.entries = this.entries.map((e) => {
                e.Time -= timeCut;
                e.End -= timeCut;
                return e;
            });
        },
        shiftToCurrentTime() {
            if (this.selectedEntry >= 0) {
                const timeTarget = this.timerTime;
                const timeshift = timeTarget - this.entries[this.selectedEntry].Time;

                for (let i = this.selectedEntry - 1; i >= 0; i -= 1) {
                    this.entries[i].End = timeTarget - (this.selectedEntry - 1 - i) * 100;
                    if (this.entries[i].Time > timeTarget) {
                        this.entries[i].Time = timeTarget - (this.selectedEntry - i) * 100;
                    } else {
                        break;
                    }
                }

                for (let i = this.selectedEntry; i < this.entries.length; i += 1) {
                    this.entries[i].End += timeshift;
                    this.entries[i].Time += timeshift;
                }
            }
            this.selectedEntry = -1;
        },
        //= ======================== ENTRY CONTROLLER ========================

        //= ------------------------ TIMELINE CONTROLLER ------------------------
        rerenderTimeline() {
            if (this.$refs.TimeCanvas1) {
                let ctx: CanvasRenderingContext2D | null = null;
                for (let i = 0; i < 3; i += 1) {
                    switch (i) {
                        case 0:
                            ctx = this.$refs.TimeCanvas1.getContext("2d");
                            this.$refs.TimeCanvas1.width = this.secToPx * this.secPerBar;
                            this.$refs.TimeCanvas1.height = this.barHeight;
                            break;

                        case 1:
                            ctx = this.$refs.TimeCanvas2.getContext("2d");
                            this.$refs.TimeCanvas2.width = this.secToPx * this.secPerBar;
                            this.$refs.TimeCanvas2.height = this.barHeight;
                            break;

                        case 2:
                            ctx = this.$refs.TimeCanvas3.getContext("2d");
                            this.$refs.TimeCanvas3.width = this.secToPx * this.secPerBar;
                            this.$refs.TimeCanvas3.height = this.barHeight;
                            break;

                        default:
                            ctx = null;
                            break;
                    }

                    if (ctx) {
                        ctx.save();
                        ctx.strokeStyle = "white";
                        ctx.fillStyle = "white";
                        ctx.font = "14px Ubuntu";
                        ctx.lineWidth = 0.35;

                        if (this.secToPx <= 60) {
                            for (let x = 0; x / 10 < this.secPerBar; x += 10) {
                                ctx.beginPath();
                                ctx.moveTo((x * this.secToPx) / 10, 0);
                                ctx.lineTo((x * this.secToPx) / 10, this.barHeight);
                                ctx.stroke();

                                ctx.fillText(this.secToTimestring(x / 10 + i * this.secPerBar + this.barCount * this.secPerBar, false, false), (x * this.secToPx) / 10 + 5, this.barHeight);
                            }

                            ctx.restore();
                        } else if (this.secToPx <= 100) {
                            for (let x = 0; x / 10 < this.secPerBar; x += 2) {
                                if (x % 10 === 0) {
                                    ctx.beginPath();
                                    ctx.moveTo((x * this.secToPx) / 10, 0);
                                    ctx.lineTo((x * this.secToPx) / 10, this.barHeight);
                                    ctx.stroke();

                                    ctx.fillText(this.secToTimestring(x / 10 + i * this.secPerBar + this.barCount * this.secPerBar, false, false), (x * this.secToPx) / 10 + 5, this.barHeight);
                                } else {
                                    ctx.beginPath();
                                    ctx.moveTo((x * this.secToPx) / 10, 0);
                                    ctx.lineTo((x * this.secToPx) / 10, (this.barHeight * 2.0) / 3.0);
                                    ctx.stroke();
                                }
                            }

                            ctx.restore();
                        } else {
                            for (let x = 0; x / 10 < this.secPerBar; x += 1) {
                                if (x % 10 === 0) {
                                    ctx.beginPath();
                                    ctx.moveTo((x * this.secToPx) / 10, 0);
                                    ctx.lineTo((x * this.secToPx) / 10, this.barHeight);
                                    ctx.stroke();

                                    ctx.fillText(this.secToTimestring(x / 10 + i * this.secPerBar + this.barCount * this.secPerBar, false, false), (x * this.secToPx) / 10 + 5, this.barHeight);
                                } else if (x % 2 === 0) {
                                    ctx.beginPath();
                                    ctx.moveTo((x * this.secToPx) / 10, 0);
                                    ctx.lineTo((x * this.secToPx) / 10, (this.barHeight * 2.0) / 3.0);
                                    ctx.stroke();
                                } else {
                                    ctx.beginPath();
                                    ctx.moveTo((x * this.secToPx) / 10, 0);
                                    ctx.lineTo((x * this.secToPx) / 10, (this.barHeight * 2.0) / 3.0);
                                    ctx.stroke();
                                }
                            }

                            ctx.restore();
                        }
                    }
                }
            }
        },
        secToTimestring(secInput: number, msOutput: boolean = true, Full: boolean = false): string {
            let Sec = secInput;
            let MS:string = Math.floor((Sec % 1) * 100).toString();
            if (MS.length === 1) {
                MS = `0${MS}`;
            }

            Sec = Math.floor(Sec);
            const H: number = Math.floor(Sec / 60 / 60);
            Sec -= H * 60 * 60;
            const M: number = Math.floor(Sec / 60);
            Sec -= M * 60;

            let Stemp:string = H.toString();
            if (Stemp.length === 1) {
                Stemp = `0${Stemp}`;
            }
            Stemp = `${Stemp}:${(`0${M.toString()}`).slice(-2)}:${(`0${Sec.toString()}`).slice(-2)}.${MS}`;

            if (Full) {
                if (msOutput) {
                    return Stemp;
                }
                return Stemp.slice(0, Stemp.length - 3);
            }
            for (let i = 0; i < 3; i += 1) {
                if (Stemp.slice(0, 2) !== "00") {
                    break;
                } else {
                    Stemp = Stemp.slice(3);
                }
            }

            if (Stemp[0] === "0") {
                Stemp = Stemp.slice(1);
            }

            if (msOutput) {
                return Stemp;
            }
            return Stemp.slice(0, Stemp.length - 3);
        },
        scrollCalculator(): void {
            const deltaBar: number = this.timerTime / 1000 / this.secPerBar - this.barCount;
            if ((deltaBar > 3) || (deltaBar < 0)) {
                const barCountNew = Math.floor(this.timerTime / 1000 / this.secPerBar);
                if (barCountNew > 0) {
                    this.barCount = barCountNew - 1;
                } else {
                    this.barCount = 0;
                }
                this.rerenderTimeline();
                this.reloadDisplayCards();
            } else if (deltaBar > 2) {
                this.barCount += 1;
                this.renderForward();
                this.reloadDisplayCards();
            } else if ((deltaBar < 1) && (this.barCount > 0)) {
                this.barCount -= 1;
                this.renderBackward();
                this.reloadDisplayCards();
            }

            this.$refs.TimelineDiv.scrollLeft = (this.timerTime / 1000 - this.barCount * this.secPerBar) * this.secToPx;
        },
        renderForward(): void {
            let ctx = this.$refs.TimeCanvas1.getContext("2d");
            if (ctx) {
                this.$refs.TimeCanvas1.width = this.secToPx * this.secPerBar;
                this.$refs.TimeCanvas1.height = this.barHeight;
                ctx.drawImage(this.$refs.TimeCanvas2, 0, 0);
            }

            ctx = this.$refs.TimeCanvas2.getContext("2d");
            if (ctx) {
                this.$refs.TimeCanvas2.width = this.secToPx * this.secPerBar;
                this.$refs.TimeCanvas2.height = this.barHeight;
                ctx.drawImage(this.$refs.TimeCanvas3, 0, 0);
            }

            ctx = this.$refs.TimeCanvas3.getContext("2d");
            this.$refs.TimeCanvas3.width = this.secToPx * this.secPerBar;
            this.$refs.TimeCanvas3.height = this.barHeight;

            if (ctx) {
                ctx.save();
                ctx.strokeStyle = "white";
                ctx.fillStyle = "white";
                ctx.font = "14px Ubuntu";
                ctx.lineWidth = 0.35;

                for (let x = 0; x / 10 < this.secPerBar; x += 1) {
                    if (x % 10 === 0) {
                        ctx.beginPath();
                        ctx.moveTo((x * this.secToPx) / 10, 0);
                        ctx.lineTo((x * this.secToPx) / 10, this.barHeight);
                        ctx.stroke();

                        ctx.fillText(this.SectoTimestring(x / 10 + 2 * this.secPerBar + this.barCount * this.secPerBar, false, false), (x * this.secToPx) / 10 + 5, this.barHeight);
                    } else if (x % 2 === 0) {
                        ctx.beginPath();
                        ctx.moveTo((x * this.secToPx) / 10, 0);
                        ctx.lineTo((x * this.secToPx) / 10, (this.barHeight * 2.0) / 3.0);
                        ctx.stroke();
                    } else {
                        ctx.beginPath();
                        ctx.moveTo((x * this.secToPx) / 10, 0);
                        ctx.lineTo((x * this.secToPx) / 10, (this.barHeight * 1.0) / 3.0);
                        ctx.stroke();
                    }
                }

                ctx.restore();
            }
        },
        renderBackward(): void {
            let ctx = this.$refs.TimeCanvas3.getContext("2d");
            if (ctx) {
                this.$refs.TimeCanvas3.width = this.secToPx * this.secPerBar;
                this.$refs.TimeCanvas3.height = this.barHeight;
                ctx.drawImage(this.$refs.TimeCanvas2, 0, 0);
            }

            ctx = this.$refs.TimeCanvas2.getContext("2d");
            if (ctx) {
                this.$refs.TimeCanvas2.width = this.secToPx * this.secPerBar;
                this.$refs.TimeCanvas2.height = this.barHeight;
                ctx.drawImage(this.$refs.TimeCanvas1, 0, 0);
            }

            ctx = this.$refs.TimeCanvas1.getContext("2d");
            this.$refs.TimeCanvas1.width = this.secToPx * this.secPerBar;
            this.$refs.TimeCanvas1.height = this.barHeight;

            if (ctx) {
                ctx.save();
                ctx.strokeStyle = "white";
                ctx.fillStyle = "white";
                ctx.font = "14px Ubuntu";
                ctx.lineWidth = 0.35;

                for (let x = 0; x / 10 < this.secPerBar; x += 1) {
                    if (x % 10 === 0) {
                        ctx.beginPath();
                        ctx.moveTo((x * this.secToPx) / 10, 0);
                        ctx.lineTo((x * this.secToPx) / 10, this.barHeight);
                        ctx.stroke();

                        ctx.fillText(this.SectoTimestring(x / 10 + this.barCount * this.secPerBar, false, false), (x * this.secToPx) / 10 + 5, this.barHeight);
                    } else if (x % 2 === 0) {
                        ctx.beginPath();
                        ctx.moveTo((x * this.secToPx) / 10, 0);
                        ctx.lineTo((x * this.secToPx) / 10, (this.barHeight * 2.0) / 3.0);
                        ctx.stroke();
                    } else {
                        ctx.beginPath();
                        ctx.moveTo((x * this.secToPx) / 10, 0);
                        ctx.lineTo((x * this.secToPx) / 10, (this.barHeight * 1.0) / 3.0);
                        ctx.stroke();
                    }
                }

                ctx.restore();
            }
        },
        reloadDisplayCards():void {
            this.timecardIdx = [];
            this.extraMargin = 0;
            for (let i = 0; i < this.entries.length; i += 1) {
                if (this.entries[i].End > (this.barCount + 3.0) * this.secPerBar * 1000) {
                    if (this.entries[i].Time < (this.barCount + 3.0) * this.secPerBar * 1000) {
                        this.timecardIdx.push(i);
                    }
                    break;
                } else if (this.entries[i].End > this.barCount * this.secPerBar * 1000) {
                    if (this.entries[i].Time >= this.barCount * this.secPerBar * 1000) {
                        this.timecardIdx.push(i);

                        if ((i === 0) && (this.entries[i].Time !== 0)) {
                            this.extraMargin = (this.entries[i].Time / 1000 - this.barCount * this.secPerBar) * this.secToPx;
                        }
                    } else {
                        this.timecardIdx.push(i);
                    }
                }
            }
        },
        cardWidthCalculator(idx: number): string {
            if ((idx !== 0) && (idx === this.timecardIdx[0])) {
                return (`${((this.entries[idx].End / 1000 - this.barCount * this.secPerBar) * this.secToPx).toString()}px`);
            } if (this.entries[idx].End > (this.barCount + 3.0) * this.secPerBar * 1000) {
                return (`${(((this.barCount + 3.0) * this.secPerBar - this.entries[idx].Time / 1000) * this.secToPx).toString()}px`);
            }
            return (`${(((this.entries[idx].End - this.entries[idx].Time) / 1000) * this.secToPx).toString()}px`);
        },
        //= ======================== TIMELINE CONTROLLER ========================
    },

};
</script>

<style>
.TopMenu {
  width:100%;
  position:absolute;
  top:0px;
  left:0px;
  z-index: 1;
}
.ColourButton {
  margin-top: 19px;
  margin-left: 5px;
}
.ProfileListCard {
  position: absolute;
  bottom: 5px;
  right: 5px;
}
.ChatPanelContainer{
  display: grid;
  grid-auto-flow: column;
}
.ControlBox{
  position: absolute;
  top: 5px;
  right: 5px;
  z-index: 1;
}
.Marker {
  position: absolute;
  left: calc(40% - 2px);
  top: 0px;
  width: 4px;
  height: 100%;
  z-index: 1;
  background-color: rgba(255, 0, 0, 0.7);
}
.TimelineContainer {
  overflow-x: hidden;
  display: flex;
  flex-direction: column;
  border-top: 2px solid white;
  padding-top: 7px;
  border-bottom: 2px solid white;
}
.TimelineInnerContainer {
  display: flex;
  flex-direction: row;
  margin-left: 40%;
  margin-bottom: 10px;
}
.TimecardContainer {
  display: flex;
  flex-direction: row;
  margin-top: 5px;
  margin-bottom: 5px;
}
.Timecard {
  display: flex;
  flex-direction: row;
  -webkit-text-stroke-width: 1px;
  align-items: center;
  font-family: Ubuntu;
  font-weight: bolder;
  border: solid 1px white;
}
</style>
